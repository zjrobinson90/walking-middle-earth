<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Journey Through Middle-earth</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.3/leaflet.css" />
    <style>
        body { margin: 0; padding: 0; }
        #map {
            width: 100%;
            height: 100vh;
        }
        .info-panel {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 1000;
            background: rgba(255, 255, 255, 0.9);
            padding: 10px;
            border-radius: 4px;
            box-shadow: 0 0 10px rgba(0,0,0,0.2);
        }
    </style>
</head>
<body>
    <div id="map"></div>
    <div class="info-panel">
        <h3>Journey Progress</h3>
        <p>Your Progress: <span id="userMiles">0</span> miles</p>
        <p>Total Journey: <span id="totalMiles">1779</span> miles</p>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.3/leaflet.js"></script>
    <script>
        // Custom tile layer to handle bounds per zoom level
        L.TileLayer.BoundedTiles = L.TileLayer.extend({
            getTileUrl: function(coords) {
                // Define valid ranges for each zoom level
                const validRanges = {
                    0: { xMin: 0, xMax: 1, yMin: 0, yMax: 1 },
                    1: { xMin: 0, xMax: 2, yMin: 0, yMax: 2 },
                    2: { xMin: 0, xMax: 5, yMin: 0, yMax: 5 },
                    3: { xMin: 0, xMax: 11, yMin: 0, yMax: 10 }
                };

                const range = validRanges[coords.z];
                
                // Check if the requested tile is within valid range
                if (range && 
                    coords.x >= range.xMin && coords.x <= range.xMax &&
                    coords.y >= range.yMin && coords.y <= range.yMax) {
                    return `/walking-middle-earth/tiles/${coords.z}/${coords.x}/${coords.y}.jpg`;
                }
                
                // Return empty tile if out of range
                return 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII=';
            }
        });

        // Initialize the map
        const map = L.map('map', {
            crs: L.CRS.Simple,
            minZoom: 0,
            maxZoom: 3,
            zoomControl: true,
            attributionControl: false
        });

        // Add the custom tile layer
        new L.TileLayer.BoundedTiles('', {
            minZoom: 0,
            maxZoom: 3,
            noWrap: true,
            tileSize: 256
        }).addTo(map);

        // Calculate bounds based on max zoom level (zoom 3)
        const maxTileX = 11;
        const maxTileY = 10;
        const tileSize = 256;
        
        // Calculate the bounds in pixels at max zoom
        const maxBounds = [
            [0, 0],
            [maxTileY * tileSize, maxTileX * tileSize]
        ];

        // Set the view to center of the map at zoom level 1
        const center = [
            (maxBounds[1][0] - maxBounds[0][0]) / 2,
            (maxBounds[1][1] - maxBounds[0][1]) / 2
        ];
        
        map.setView(center, 1);
        map.setMaxBounds(maxBounds);

        // Prevent zooming too far or panning outside bounds
        map.on('drag', function() {
            map.panInsideBounds(maxBounds, { animate: false });
        });
    </script>
</body>
</html>
